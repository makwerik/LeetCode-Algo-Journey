# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def inorderTraversal(self, root):
        """
        Первый метод обход дерева через стек.
        Мы создаём массив для хранения результатов. Так же создаём стек, куда будет помещаться узел.
        Суть такая что мы итерируемся по дереву пока узел не пуст и пока есть стек.
        Если узел не пуст - кладём этот узел в стек и переходим дальше влево.
        Если узел пуст - достаём из стека узел, добавляем его значение в массив результатов и переключаемся на правый
        узел.
        (более читаемая вариация алгоритма:
        1. Создаём список для результата и пустой стек.
        2. Пока существует текущий узел или стек не пуст:
           - Если текущий узел не None:
               * добавляем его в стек
               * двигаемся к его левому потомку
           - Иначе:
               * достаём узел из стека
               * добавляем его значение в результат
               * переходим к его правому потомку
        3. Возвращаем список с результатом обхода.)
        """

        result = []
        # Создаём пустой стек
        stack = []

        # Получаем текущий узел
        node = root

        # Пока стек и узел не пуст
        while stack or node:
            if node:
                # Если узел не пуст добавляем его в стек и идём дальше
                stack.append(node)
                node = node.left
            else:
                # Если узел пуст достаём последний из стека и добавляем значение
                node = stack.pop()
                result.append(node.val)
                node = node.right

        return result


    def inorderTraversal2(self, root):
        """
        Рекурсивный обход дерева.
        Алгоритм работы:
            Создаём массив для хранения результатов.
            Проверяем что узел не пустой, в случе если узел пуст - выходим из функции.
            Создаём функцию, которая будет рекурсивно проходить по узлам:
                Вызываем рекурсивно функцию для левого узла.
                Добавляем значение (node.val) в массив результатов.
                Вызываем рекурсивно функцию для правого узла.
            Инициализируем рекурсивную функцию.
            Возвращаем результат

        (Алгоритм:
        1. Если дерево пустое, возвращаем пустой список.
        2. Определяем вспомогательную функцию `inorder(node)`:
           - если node пустой → выходим (базовый случай),
           - иначе:
             * рекурсивно обходим левое поддерево,
             * добавляем значение узла в результат,
             * рекурсивно обходим правое поддерево.
        3. Запускаем `inorder` от корня.
        4. Возвращаем список значений.)
        """
        # Массив для хранения результатов
        result = []

        def inorder(node):
            """
            Функция для рекурсивного прохода по узлам.

            :param node: Узел.
            """

            if node is None:
                return
            # Идём влево до конца
            inorder(node=node.left)

            result.append(node.val)

            # Идём вправо
            inorder(node=node.right)

        # Инициализация
        inorder(node=root)

        return result